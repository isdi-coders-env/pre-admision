# Sentencias de c√≥digo

-   Expresiones. Operadores

    -   Operadores de asignaci√≥n
    -   Operadores aritm√©ticos
    -   Operadores de comparaci√≥n
    -   Casting y coercion
    -   Casos pintorescos de coercion
    -   Coercion a boolean

-   Sentencias de control. Concepto
-   Iteraciones (Bucles)
    -   N√∫meros aleatorios
    -   While
    -   For
    -   Iterables
    -   Arrays multi dimensionales. Bucles anidados
-   Condiciones
    -   If - else
    -   Switch - case

## Expresiones. Operadores

Como ya sabemos, las sentencias de JS pueden incorporar **expresiones**. Tas es el caso de las sentencias de asignaci√≥n o de las condicione que aparecer√°n en las sentencias de control que luego veremos.

Una expresi√≥n puede incluir literales, variables y operadores y siempre se eval√∫a a un **√∫nico valor**.

Existen distintos tipos de operadores

-   operadores de asignaci√≥n
-   operadores aritm√©ticos
-   operadores de comparaci√≥n
-   operadores bit a bit
-   operadores l√≥gicos
-   operadores de cadena
-   operador condicional (ternario)
-   operador coma
-   operadores unarios
-   operadores relacionales

### Operadores de asignaci√≥n

Como ya sabemos el operador de **asignaci√≥n** es el simbolo **igual** (=)

---

ü•∑Existen adem√°s una serie de operadores que combinan la asignaci√≥n con una operaci√≥n aritm√©tica escribi√©ndolo de forma abreviada. Excepto el primero, no se usan mucho y por el momento ppuedes olvidarte de ellos

-   asignaci√≥n de adici√≥n x += y (x = x + y)
-   asignaci√≥n de resta x -= y (x = x - y)
-   asignaci√≥n de multiplicaci√≥n x _= y (x = x _ y)
-   asignaci√≥n de divisi√≥n x /= y (x = x / y)
-   asignaci√≥n de resto x %= y (x = x % y)
-   asignaci√≥n de exponenciaci√≥n x **= y (x = x ** y)

---

### Operadores aritm√©ticos

Operaciones aritm√©ticas est√°ndar

-   suma (+)
-   resta (-)
-   producto (\*)
-   divisi√≥n (/)
-   resto o m√≥dulo (%)
-   exponente (\*\*)
-   signo positivo (+)
-   signo negativo (-)

Otros aritm√©ticos mutables, que modifican la variable a la que se aplican

-   incremento (++)
-   decremento (--)

```js
const num = 3;
console.log(num + num); // 6
console.log(num - num); // 0
console.log(num * num); // 9
console.log(num / num); // 1
console.log(num % num); // 0
console.log(num ** num); // 27
console.log(+num); // 3
console.log(-num); // -3

let num1 = 3;
num1++;
console.log(num1); // 4
num1--;
console.log(num1); // 3
```

### Operadores de comparaci√≥n

Como su nombre indica comparan dos valores y devuelven un valor l√≥gico (boolean), true o false, en funci√≥n del resultado.

Comparaciones de igualdad

-   Igual (==). Devuelve true si los operandos son iguales.
-   No es igual (!=). Devuelve true si los operandos no son iguales.
-   Estrictamente igual (===). Devuelve true si los operandos son iguales y del mismo tipo.
-   Desigualdad estricta (!==). Devuelve true si los operandos son del mismo tipo pero no iguales, o son de diferente tipo.

```js
const foo = 3;
const bar = 4;
// Igualdad
console.log(3 == foo); // true
console.log("3" == foo); // true
console.log(3 == "3"); // true
console.log(foo != 4); // true
console.log(bar != "3"); // true
// Igualdad estricta
console.log(3 === foo); // true
console.log(foo !== "3"); // true
console.log(3 !== "3"); // true
```

Mayor o menor

-   Mayor que (>)
-   Mayor o igual que (>=)
-   Menor que (<)
-   Menor o igual (<=)

```js
const foo = 3;
const bar = 4;
console.log(bar > foo); // true
console.log("12" > 2); // true
console.log(bar >= foo); // true
console.log(foo >= 3); // true
console.log(foo < bar); // true
console.log("2" < 12); // true
console.log(foo <= bar); // true
```

Para entender el funcionamiento de los operadores en relaci√≥n con los tipos tenemos que mencionar los conceptos de casting y coercion.

### Casting y coercion

Casting es el proceso de utilizaci√≥n durante una determinada operaci√≥n del equivalente a una variable cambi√°ndole el tipo, con el fin de poder llevar a cabo la operaci√≥n. Dicho de otra manera, es la acci√≥n de forzar a que una variable se comporte como si fuera de otro tipo.

Este proceso puede ser

-   expl√≠cito, cuando se indica en el c√≥digo que se debe producir. Se suele denominar casting
-   impl√≠cito, cuando lo realiza autom√°ticamente el lenguaje. Se suele denominar coercion. En JS este proceso se realiza siempre que resulta necesario para que se pueda evaluar una expresi√≥n.

Veamos un ejemplo para terminar de entender el proceso.

```js
const foo = 12; // tipo number
const bar = "3"; // tipo string

const result = foo / bar;

// La divisi√≥n solo tiene sentido entre dos operadores num√©ricos
// JS aplica sus reglas de coercion y en lugar del valor real de bar utiliza su equivalente num√©rico 3
// De esta forma puede evaluar la expresi√≥n 12/3 a 4 y asignar el resultado a result

console.log(result, typeof result); // 4 number

// Como puedes ver ni foo ni bar han cambiado ni de valor ni de tipo
console.log(foo, typeof foo); // 12 number
console.log(bar, typeof bar); // 3 string
```

En algunos casos las reglas de coercion no dan el resultado esperado y es necesario emplear un casting explicito para corregirlas. De momento basta con que sepas que estos procesos existen.

### Casos pintorescos de coercion

Pese a lo que acabamos de decir, hay un par de situaciones de JS que pueden resultar sorprendentes y que vamos a comentar

El primero de ellos se refiere al **operador +**, que incluye tanto las suma como la concatenaci√≥n, pero da prioridad a esta √∫ltima.

```js
const foo = 3;
const bar = "4";
const result = foo + bar;
console.log(result, typeof result); // 34 string
```

Para evitar esta situaci√≥n podemos emplear el **casting explicito** a number:

-   con la funci√≥n de casting Number()
-   aplicando el operador de signo +

```js
const foo = 3;
const bar = "4";
let result = foo + bar;
console.log(result, typeof result); // 34 string
result = foo + Number(bar);
console.log(result, typeof result); // 7 number
result = foo + +bar;
console.log(result, typeof result); // 7 number
```

El segundo caso se refiere a la **coercion a number de los string**. Con un string num√©rico no hay problema: en lugar de '9' usamos el n√∫mero 9. Pero, ¬øcomo puede JS calcular el numero equivalente a un string que no se refiere a n√∫meros?. Para eso existe una entidad especial, dentro del conjunto de los valores de tipo number, conocida como **NaN** (not-a-number) que representa un n√∫mero cuyo valor es indeterminado.

Aunque matem√°ticamente existen la indeterminaciones, en la pr√°ctica suele ser poco util un valor Nan. Ya aprender√°s como programamos para evitas que aparezcan valores NaN

### Coercion a boolean

El caso m√°s llamativo en que JS realiza la coercion autom√°tica es cuando se espera un boolean, como en las condiciones de if o the while que luego veremos. En esta situaci√≥n cualquier variable se convierte a true, y se denomina **truthy**, excepto unos pocos valores conocidos como **falsy**

-   false
-   0, -0 y 0n (el bigInt 0)
-   undefined
-   null
-   NaN (el numero indeterminado, not-a-number)
-   '' (el string vac√≠o)

Para que compruebes esta conversi√≥n podemos usar la funci√≥n de casting explicito Boolean

```js
console.log(Boolean(false)); // false
console.log(Boolean(null)); // false
console.log(Boolean(undefined)); // false
console.log(Boolean(0)); // false
console.log(Boolean(-0)); // false
console.log(Boolean(0n)); // false
console.log(Boolean(NaN)); // false
console.log(Boolean("")); // false
```

> üõ†Ô∏è Si pruebas cualquier otro valor, veras que se eval√∫a a true

## Sentencias de control. Concepto

Ya sabemos que nuestros programas son uns serie de **sentencias** que se ejecutan una tras otra. Sin embargo solo esto, ser√≠a una forma muy limitada de organizar el c√≥digo. Po eso surgen los **bloques**, limitados mediante llaves ({}) y la posibilidad de utilizarlos en al menos tres estructuras de control del flujo se la aplicaci√≥n.

-   las **funciones**: bloque de c√≥digo que pueden tener un nombre y ser ejecutados cada vez que se invocan.
-   las **iteraciones**, que permiten repetir un bloque un n√∫mero determinado de veces
-   las **condiciones**, que permiten decidir si un bloque se ejecuta o no en funci√≥n del valor devuelto por una expresi√≥n.

---

ü•∑ En JS original s√≥lo lo hac√≠an las funciones, pero en ES6+, cualquier bloque de c√≥digo delimita un **√°mbito (scope) de memoria**. Las variables declaradas con let y const existen solo en ese √°mbito y nunca pueden ser accedidas desde otros √°mbitos por encima de aquel en el que se han declarado.

---

üéØ Las **funciones** son sin duda las estructuras m√°s importantes de JS y a ellas dedicaremos gran parte de nuestra formaci√≥n, pero por ahora vamos a trabajar sin crear funciones

## Iteraciones (Bucles)

> [üìπvideo 5](https://www.youtube.com/FALTA EL ENLACE)

JS proporciona dos tipos de estructuras de iteraci√≥n

-   las que dependen de una condici√≥n indepenciente del n√∫mero de ciclos, normalmente mediante `while` y `do ... while`
-   las que se ejecutan un n√∫mero determinado de veces, normalmente mediante diversas variaciones de `for`

### N√∫meros aleatorios

En JavaScript disponemos de un objeto Math que nos proporciona diversas constantes matem√°ticas (como Math.PI), junto con m√©todos de c√°lculo, como **Math.random()**, que nos interesa en este momento.

Este m√©todo genera un n√∫mero aleatorio decimal (punto flotante) desde 0 hasta el valor inmediatamente anterior a 1.

Frecuentemente querremos un entero dentro de un **rango**, entre min y max, por ejemplo entre 0 y 10).

Para ello, sin min es 0, multiplicamos el valor aleatorio por max y lo redondeamos, usando de nuevo un m√©todo de Math, en este caso Math.round()

```js
const max = 2;
const randomNumber = Math.round(Math.random() * max);
console.log(randomNumber);
```

> üõ†Ô∏è Si ejecutas este c√≥digo varias veces, veras como obtienes 0, 1 o 2.

Si el rango no empieza en 0, el c√≥digo sera el siguiente.

```js
const min = 1;
const max = 2;
const randomNumber = Math.round(Math.random() * (max - min) + min);
console.log(randomNumber);
```

### While

Permite hacer una iteraci√≥n mientras se cumpla una condici√≥n, sin saber a priori cuantos resultados obtenemos.

Por ejemplo, queremos tirar un dada hasta que nos salga un 6

```js
const min = 1;
const max = 6;
let r = 0;
while (r < 6) {
    r = Math.round(Math.random() * (max - min) + min);
    console.log(r);
}
console.log("Fin de la serie");
```

En el inicio del bucle definimos la condici√≥n.
Si se cumple, se ejecuta el bloque.
Se eval√∫a de nuevo la condici√≥n.
Si se cumple, se ejecuta nuevamente el bloque.
Y as√≠ hasta que la condici√≥n no se cumpla.
S√≥lo entonces se contin√∫a ejecutando el c√≥digo posterior al bloque.

Aunque no sabemos el n√∫mero de vueltas que se producir√°n, podemos incorporar un contador que nos indique en que iteraci√≥n estamos. Ser√° el c√≥digo del bloque el responsable de mantenerlo actualizado

```js
const min = 1;
const max = 6;
let r = 0;
let i = 0;
while (r < 6) {
    r = Math.round(Math.random() * (max - min) + min);
    i++;
    console.log(`La tirada ${i} vale ${r}`);
}
console.log(`Fin de la serie de ${i} tiradas`);
```

---

ü•∑ Si la condici√≥n hace referencia al contador, y el bucle lo actualiza como en el ejemplo, podr√≠amos emular en el while el comportamiento que luego veremos en el for

---

Existe una variaci√≥n de esta estructura, el **do...while**, que eval√∫a la condici√≥n al final, en lugar de al principio, pero en nuestro ejemplo funcionar√≠a exactamente igual.

```js
const min = 1;
const max = 6;
// Aunque r comienza en 6, el bucle funciona
// porque el valor de r se eval√∫a despu√©s de la primera ejecuci√≥n del bloque
// por tanto con el primer n√∫mero random
let r = 6;
let i = 0;
do {
    r = Math.round(Math.random() * (max - min) + min);
    i++;
    console.log(`La tirada ${i} vale ${r}`);
} while (r < 6);
console.log(`Fin de la serie de ${i} tiradas`);
```

### For

Permite hacer una iteraci√≥n un determinado n√∫mero de veces, que definimos a priori.

Por ejemplo, queremos tirar un dado 10 veces

```js
const min = 1
const max = 6;
for (let i = 0; i < 10, i++) {
    const r =  Math.round(Math.random()*(max-min) + min);
    console.log(r);
}
```

En la estructura del for incluimos 3 sentencias de ejecuci√≥n (separadas por ;)

-   la que declara una variable contador (generalmente llamada i, de √≠ndice) y le asigna el valor inicial, habitualmente 0 o 1
-   la que establece la condici√≥n que debe cumplirse para que se ejecute la siguiente interacci√≥n, normalmente en funci√≥n del valor del contador
-   la que define como se modifica el contador en cada vuelta, normalmente incrementando en 1. la expresi√≥n i++ es una forma abreviada de i = i + 1

---

ü•∑ Tambi√©n puede haber iteraciones en sentido inverso, empezando en un valor y restando 1 en cada vuelta. Igualmente es posible, aunque no lo mas habitual incrementar o decrementar el contador en una cantidad distinta de 1.

---

Dentro del bloque del for podemos evaluar una condici√≥n mediante if, y disponemos de dos operaciones posibles

-   `break`, permite abandonar el bucle y continuar con el c√≥digo posterior al bloque
-   `continue`, permite abandonar la iteraci√≥n actual: el contador aumenta en 1 y el ciclo de iteraciones sigue su curso

### Iterables

Son las estructuras de datos que se pueden recorrer mediante un for, como es el caso de arrays y de strings.

```js
const users = ["Pepe", "Luisa", "Elena", "Ernesto"];
for (let i = 0; i < users.length; i++) {
    const item = users[i];
    console.log(`Hola, soy ${item}, el usuario n√∫mero ${i + 1}`);
}
console.log("Esto es todo");
```

En cada vuelta o iteraci√≥n tenemos dos elementos

-   el indice i, que recoge la posici√≥n en la que estamos
-   el iterador, que recoge el valor de la posici√≥n. Puede ser una variable, en nuestro ejemplo item, o simplemente la expresi√≥n que asignamos a esa variable, array[i].

üéØ Muchos de los problemas al recorrer un array vienen de confundir estos elementos.

> üõ†Ô∏è Observa que al indicar la posici√≥n en la consola empleamos i + 1: el mundo no entiende que empecemos a contar desde 0, as√≠ que hacemos las cuentas desde 1.

Como hemos visto los string tambi√©n son iterables.

```js
const word = "Elefante";
for (let i = 0; i < word.length; i++) {
    const item = word[i];
    console.log(`Hola, la letra ${i + 1} de ${word} es ${item}`);
}
console.log("Esto es todo");
```

En el caso de los arrays, en cada iteraci√≥n podemos no solo mostrar el valor, sino tambi√©n modificarlo.

Por ejemplo, queremos los cuadrados de los n√∫meros de un array.

```js
const numbers = [12, 25, 31, 42, 52];
console.log(numbers); // [ 12, 25, 31, 42, 52 ]
for (let i = 0; i < numbers.length; i++) {
    let item = numbers[i];
    numbers[i] = item * item;
}
console.log(numbers); // [ 144, 625, 961, 1764, 2704 ]
```

En el caso de los strings, no es posible cambiar el valor de cada posici√≥n: son iterables de solo lectura.

### Arrays multi dimensionales. Bucles anidados

Cuando los elementos de un array son arrays, tenemos un array de dos **dimensiones**. Si sucede lo mismo en el array interior sucesivamente, podemos tener n dimensiones. En algunas ocasiones encontraras el nombre de matrices para referirse a estas estructuras pero en JS no son otra cosa que arrays.

Para recorrer estos arrays necesitamos anidar un bucle for por cada dimensi√≥n

Veamos un ejemplo con dos dimensiones.

```js
const matrix = [
    [1, 2, 3],
    [10, 20, 30],
    [100, 200, 300],
];
for (let i = 0; i < matrix.length; i++) {
    const line = matrix[i];
    for (let j = 0; j < line.length; j++) {
        const item = line[j];
        console.log(`En la l√≠nea ${i + 1}, el valor ${j + 1} es  ${item} `);
    }
}
```

## Condiciones

> [üìπvideo 6](https://www.youtube.com/FALTA EL ENLACE)

### If - else

La estructura **if** permite definir una condici√≥n asociada a un bloque, que se ejecutar√° solo si se cumple dicha condici√≥n. Se puede complementar con el **else** para indicar el bloque alternativo, que se ejecutar√° si no se cumple la condici√≥n.

En nuestro ejemplo vamos a distinguir pares e impares.
Para ello tenemos el operador de modulo o resto (%) que devuelve el resto de una divisi√≥n

-   en los pares el resto es 0: n%2 = 0
-   en los impares es 1: n%2 = 1

```js
const max = 100;
const num = Math.round(Math.random() * max);

if (num % 2 === 0) {
    console.log(`El n√∫mero ${num} es par`);
} else {
    console.log(`El n√∫mero ${num} es impar`);
}
```

Si se necesita evaluar mas posibilidades se pueden a√±adir todas las condiciones requeridas, mediante else if

```js
const user = { age: 10, name: `Pepe`, gender: "male" };

if (user.age <= 10) {
    console.log("Los ni√±os no pueden entrar");
} else if (user.age < 18) {
    console.log("Los menores deben ir acompa√±ados");
} else if (user.gender === "male") {
    console.log(`Bienvenido, ${user.name}`);
} else {
    console.log(`Bienvenida, ${user.name}`);
}
```

> üõ†Ô∏è Prueba este c√≥digo cambiando los valores de las propiedades del objeto

### Switch - case

Una estructura similar a la anterior, para el caso en que todas los condiciones se refieran a la misma variable, es el **switch ... case**.

```js
const language = "En";
let greeting;
switch (language) {
    case "En":
        greeting = "Hello my friend";
        break;
    case "Es":
        greeting = "Hola amigo";
        break;
    case "Fr":
        greeting = "Salut mon ami";
        break;
    case "De":
        greeting = "Hallo Freund";
        break;
    default:
        greeting = "Hi";
        break;
}
console.log(greeting);
```

> üõ†Ô∏è Prueba este c√≥digo cambiando los valores de la variable `language`

Observa que al final de cada caso hay un `break`. En caso contrario, al entrar en un caso se ejecuta dodo el resto del switch. esto puede ser util en otras circunstancias, pero no en nuestro ejemplo.
